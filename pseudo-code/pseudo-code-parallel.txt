// ================= Parallel Neutron Transport Simulation =================
//
//   C          = total cross-section (Cc + Cs)
//   Cs         = cross-section for scattering
//   Cc         = cross-section for capture
//   One_over_C = 1.0 / C used in path length calculation
//   Cc_over_C  = Cc / C gives the probability of absorption
//   W          = plate thickness (also referred to as plate_width)
//   L          = distance travelled by neutron before next collision
//   theta      = scattering angle in radians (0 to pi)
//   randomNum  = random number between 0.0 and 1.0
//   x          = horizontal position of neutron in the plate
//   N          = number of neutrons fired per thickness
//   stillBouncing = control flag (1 = neutron still moving, 0 = stopped)
//   numR, numA, numT = counters for reflected, absorbed, transmitted
//   num_cores  = number of processor threads for simulation
//   M_PI       = value for pi (from <math.h>)
//
// ------------------------------------------------------------------------------------
//
// Custom data structures:
//   output_WRAT_t  = stores one set of results (W, numR, numA, numT)
//   thread_args_t  = holds arguments for each thread (thread_id, start_thickness,
//                    end_thickness, pointer to shared array, starting index)
//
// ------------------------------------------------------------------------------------
//
// Thread function (process_neutron_loop):
//    Get arguments passed to this thread (id, start/end thickness, output array info)
//   Set up random number generator buffer and seed for this thread
//   Set output_index = starting index for this thread in shared results array
//
//   For each plate_thickness from start_thickness up to end_thickness, step by THICKNESS_INCREMENT:
//       - Reset numR, numA, numT = 0
//
//       For i = 1 to N (each neutron):
//           - Initialise: theta = 0, x = 0, stillBouncing = 1
//
//           While stillBouncing == 1:
//                Generate a random number (randomNum)
//                Calculate free path length: L = -One_over_C * log(randomNum)
//                Update position: x = x + L * cos(theta)
//
//               - If x < 0 neutron reflected, numR++ and stop loop (stillBouncing = 0)
//               - Else if x >= plate_thickness neutron transmitted, numT++ and stop
//               - Else if randomNum < Cc_over_C  neutron absorbed, numA++ and stop
//               - Else → neutron scattered, update angle: theta = randomNum * π
//           End while (end of single neutron path)
//
//       End For (all neutrons fired at this thickness)
//
//     Save results into output array at output_index:
//           output_arr_ptr[output_index].W = plate_thickness
//           output_arr_ptr[output_index].numR = numR
//           output_arr_ptr[output_index].numA = numA
//           output_arr_ptr[output_index].numT = numT
//        Increment output_index
//
//   End For (all thickness values handled by this thread)
//
//   //Return 0 when finished
//
// 
//
// Helper function (write_WRAT_data):
//   Input: file pointer output array array length
//   -   For each element of output array (i = 0 to length-1):
//          Write a line to file with values:
//           W, numR, numA, numT
//
// ------------------------------------------------------------------------------------
//
// Main program:
//   - Record start time (GET_TIME)
//   - Declare local variables (output file pointer, timers, etc.)
//
//   - Get number of processor cores from system (sysconf)
//   - Parse command line arguments:
//       If argc < 2  print usage message and exit
//       Else:
//           num_cores = threads requested (or all cores if user passed 0)
//           If argc >= 3 open output file
//           Else  open default file "data/WRAT_parallel.dat"
//
//   - Work out total number of thickness iterations
//   - Calculate load_per_core = how many iterations each thread does
//   - Calculate thickness_increment_per_core = range of W values for each thread
//
//   - Declare arrays for pthread_t, thread_args_t, and results buffer
//
//   - For i = 0 to num_cores-1 (thread creation loop):
//       - Fill in simulation_args[i] with id, thickness range, output array, and offset
//       - Create thread i, passing process_neutron_loop and its arguments
//       - If creation fails = print error and exit
//
//    For i = 0 to num_cores-1 (thread join loop):
//       - Wait for thread i to finish
//       - If join fails  print error and exit
//
//   - If DEBUG_LEVEL > 0 print results to terminal
//   Call write_WRAT_data(fp_WRAT, output_array, num_thickness_iterations)
//   - Close output file
//
//    Record end time and compute elapsed = end - start
//    Print elapsed time (seconds and minutes)
//
//    Return 0 (successful exit)
//
// ====================================================================================
